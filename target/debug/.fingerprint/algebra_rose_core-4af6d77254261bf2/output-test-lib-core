{"$message_type":"diagnostic","message":"cannot apply unary operator `-` to type `usize`","code":{"code":"E0600","explanation":"An unary operator was used on a type which doesn't implement it.\n\nErroneous code example:\n\n```compile_fail,E0600\nenum Question {\n    Yes,\n    No,\n}\n\n!Question::Yes; // error: cannot apply unary operator `!` to type `Question`\n```\n\nIn this case, `Question` would need to implement the `std::ops::Not` trait in\norder to be able to use `!` on it. Let's implement it:\n\n```\nuse std::ops::Not;\n\nenum Question {\n    Yes,\n    No,\n}\n\n// We implement the `Not` trait on the enum.\nimpl Not for Question {\n    type Output = bool;\n\n    fn not(self) -> bool {\n        match self {\n            Question::Yes => false, // If the `Answer` is `Yes`, then it\n                                    // returns false.\n            Question::No => true, // And here we do the opposite.\n        }\n    }\n}\n\nassert_eq!(!Question::Yes, false);\nassert_eq!(!Question::No, true);\n```\n"},"level":"error","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":1444,"byte_end":1457,"line_start":42,"line_end":42,"column_start":34,"column_end":47,"is_primary":true,"text":[{"text":"                        PHI.powi(-((i*j) % 13) as i32),","highlight_start":34,"highlight_end":47}],"label":"cannot apply unary operator `-`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"unsigned values cannot be negated","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0600]\u001b[0m\u001b[1m: cannot apply unary operator `-` to type `usize`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mCORE/src/matrix_444.rs:42:34\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         PHI.powi(-((i*j) % 13) as i32),\n   \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcannot apply unary operator `-`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: unsigned values cannot be negated\n\n"}
{"$message_type":"diagnostic","message":"cannot divide `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<..., ..., ...>>` by `f64`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":1789,"byte_end":1790,"line_start":53,"line_end":53,"column_start":21,"column_end":22,"is_primary":true,"text":[{"text":"        data = data / norm;","highlight_start":21,"highlight_end":22}],"label":"no implementation for `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<..., ..., ...>> / f64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Div<f64>` is not implemented for `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<..., ..., ...>>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Div<Rhs>`:\n  `&Matrix<T, R, C, S>` implements `Div<T>`\n  `&Matrix<T, R1, C1, SA>` implements `Div<&Rotation<T, D2>>`\n  `&Matrix<T, R1, C1, SA>` implements `Div<Rotation<T, D2>>`\n  `Matrix<T, R, C, S>` implements `Div<T>`\n  `Matrix<T, R1, C1, SA>` implements `Div<&Rotation<T, D2>>`\n  `Matrix<T, R1, C1, SA>` implements `Div<Rotation<T, D2>>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/workspaces/AR_app/target/debug/deps/core-4af6d77254261bf2.long-type-14235176411787198658.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: cannot divide `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<..., ..., ...>>` by `f64`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mCORE/src/matrix_444.rs:53:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         data = data / norm;\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mno implementation for `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<..., ..., ...>> / f64`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `Div<f64>` is not implemented for `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<..., ..., ...>>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Div<Rhs>`:\n             `&Matrix<T, R, C, S>` implements `Div<T>`\n             `&Matrix<T, R1, C1, SA>` implements `Div<&Rotation<T, D2>>`\n             `&Matrix<T, R1, C1, SA>` implements `Div<Rotation<T, D2>>`\n             `Matrix<T, R, C, S>` implements `Div<T>`\n             `Matrix<T, R1, C1, SA>` implements `Div<&Rotation<T, D2>>`\n             `Matrix<T, R1, C1, SA>` implements `Div<Rotation<T, D2>>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/workspaces/AR_app/target/debug/deps/core-4af6d77254261bf2.long-type-14235176411787198658.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `from_column_iterator` found for struct `Matrix<T, R, C, S>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":2097,"byte_end":2117,"line_start":63,"line_end":63,"column_start":30,"column_end":50,"is_primary":true,"text":[{"text":"        let input = DMatrix::from_column_iterator(","highlight_start":30,"highlight_end":50}],"label":"function or associated item not found in `Matrix<_, Dyn, Dyn, VecStorage<_, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Matrix<_, Dyn, Dyn, VecStorage<_, Dyn, Dyn>>` consider using one of the following associated functions:\nMatrix::<T, R, C, S>::from_data_statically_unchecked\nMatrix::<T, Dyn, Dyn, VecStorage<T, Dyn, Dyn>>::from_vec_storage\nMatrix::<T, R, C, S>::from_data","code":null,"level":"note","spans":[{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nalgebra-0.32.6/src/base/matrix.rs","byte_start":15905,"byte_end":15986,"line_start":317,"line_end":317,"column_start":5,"column_end":86,"is_primary":true,"text":[{"text":"    pub const unsafe fn from_data_statically_unchecked(data: S) -> Matrix<T, R, C, S> {","highlight_start":5,"highlight_end":86}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nalgebra-0.32.6/src/base/matrix.rs","byte_start":17104,"byte_end":17175,"line_start":346,"line_end":346,"column_start":5,"column_end":76,"is_primary":true,"text":[{"text":"    pub const fn from_vec_storage(storage: VecStorage<T, Dyn, Dyn>) -> Self {","highlight_start":5,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nalgebra-0.32.6/src/base/matrix.rs","byte_start":19479,"byte_end":19512,"line_start":403,"line_end":403,"column_start":5,"column_end":38,"is_primary":true,"text":[{"text":"    pub fn from_data(data: S) -> Self {","highlight_start":5,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is an associated function `from_iterator` with a similar name","code":null,"level":"help","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":2097,"byte_end":2117,"line_start":63,"line_end":63,"column_start":30,"column_end":50,"is_primary":true,"text":[{"text":"        let input = DMatrix::from_column_iterator(","highlight_start":30,"highlight_end":50}],"label":null,"suggested_replacement":"from_iterator","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `from_column_iterator` found for struct `Matrix<T, R, C, S>` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mCORE/src/matrix_444.rs:63:30\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let input = DMatrix::from_column_iterator(\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `Matrix<_, Dyn, Dyn, VecStorage<_, Dyn, Dyn>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `Matrix<_, Dyn, Dyn, VecStorage<_, Dyn, Dyn>>` consider using one of the following associated functions:\n      Matrix::<T, R, C, S>::from_data_statically_unchecked\n      Matrix::<T, Dyn, Dyn, VecStorage<T, Dyn, Dyn>>::from_vec_storage\n      Matrix::<T, R, C, S>::from_data\n   \u001b[1m\u001b[94m--> \u001b[0m/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nalgebra-0.32.6/src/base/matrix.rs:317:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m317\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub const unsafe fn from_data_statically_unchecked(data: S) -> Matrix<T, R, C, S> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m346\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub const fn from_vec_storage(storage: VecStorage<T, Dyn, Dyn>) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m403\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_data(data: S) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an associated function `from_iterator` with a similar name\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[91m- \u001b[0m        let input = DMatrix::\u001b[91mfrom_column_iterator\u001b[0m(\n \u001b[1m\u001b[94m63\u001b[0m \u001b[92m+ \u001b[0m        let input = DMatrix::\u001b[92mfrom_iterator\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `norm` found for struct `nalgebra::Complex<T>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nalgebra-0.32.6/src/base/unit.rs","byte_start":3388,"byte_end":3392,"line_start":112,"line_end":112,"column_start":8,"column_end":12,"is_primary":false,"text":[{"text":"    fn norm(&self) -> Self::Norm;","highlight_start":8,"highlight_end":12}],"label":"the method is available for `nalgebra::Complex<f64>` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"CORE/src/matrix_444.rs","byte_start":4040,"byte_end":4044,"line_start":127,"line_end":127,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"            assert_abs_diff_eq!(eigen.norm(), expected_magnitude, epsilon = 1e-10);","highlight_start":39,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `Normed` which provides `norm` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":3080,"byte_end":3080,"line_start":98,"line_end":98,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use nalgebra::Normed;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `norm1` with a similar name","code":null,"level":"help","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":4040,"byte_end":4044,"line_start":127,"line_end":127,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"            assert_abs_diff_eq!(eigen.norm(), expected_magnitude, epsilon = 1e-10);","highlight_start":39,"highlight_end":43}],"label":null,"suggested_replacement":"norm1","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `norm` found for struct `nalgebra::Complex<T>` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mCORE/src/matrix_444.rs:127:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m127\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             assert_abs_diff_eq!(eigen.norm(), expected_magnitude, epsilon = 1e-10);\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nalgebra-0.32.6/src/base/unit.rs:112:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn norm(&self) -> Self::Norm;\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mthe method is available for `nalgebra::Complex<f64>` here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `Normed` which provides `norm` is implemented but not in scope; perhaps you want to import it\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse nalgebra::Normed;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `norm1` with a similar name\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m127\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            assert_abs_diff_eq!(eigen.norm\u001b[92m1\u001b[0m(), expected_magnitude, epsilon = 1e-10);\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `argument` found for struct `nalgebra::Complex<T>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/simba-0.8.1/src/scalar/complex.rs","byte_start":1401,"byte_end":1425,"line_start":40,"line_end":40,"column_start":16,"column_end":40,"is_primary":false,"text":[{"text":"            fn [<$($prefix)* argument>](self) -> Self::$RealField;","highlight_start":16,"highlight_end":40}],"label":"the method is available for `nalgebra::Complex<f64>` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/simba-0.8.1/src/scalar/complex.rs","byte_start":7274,"byte_end":7307,"line_start":186,"line_end":186,"column_start":5,"column_end":38,"is_primary":false,"text":[{"text":"    complex_trait_methods!(RealField);","highlight_start":5,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"complex_trait_methods!","def_site_span":{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/simba-0.8.1/src/scalar/complex.rs","byte_start":559,"byte_end":6450,"line_start":21,"line_end":160,"column_start":1,"column_end":3,"is_primary":false,"text":[{"text":"macro_rules! complex_trait_methods(","highlight_start":1,"highlight_end":36},{"text":"    ($RealField: ident $(, $prefix: ident)*) => {","highlight_start":1,"highlight_end":50},{"text":"        paste::item! {","highlight_start":1,"highlight_end":23},{"text":"            /// Builds a pure-real complex number from the given value.","highlight_start":1,"highlight_end":72},{"text":"            fn [<from_ $($prefix)* real>](re: Self::$RealField) -> Self;","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// The real part of this complex number.","highlight_start":1,"highlight_end":54},{"text":"            fn [<$($prefix)* real>](self) -> Self::$RealField;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// The imaginary part of this complex number.","highlight_start":1,"highlight_end":59},{"text":"            fn [<$($prefix)* imaginary>](self) -> Self::$RealField;","highlight_start":1,"highlight_end":68},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// The modulus of this complex number.","highlight_start":1,"highlight_end":52},{"text":"            fn [<$($prefix)* modulus>](self) -> Self::$RealField;","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// The squared modulus of this complex number.","highlight_start":1,"highlight_end":60},{"text":"            fn [<$($prefix)* modulus_squared>](self) -> Self::$RealField;","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// The argument of this complex number.","highlight_start":1,"highlight_end":53},{"text":"            fn [<$($prefix)* argument>](self) -> Self::$RealField;","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// The sum of the absolute value of this complex number's real and imaginary part.","highlight_start":1,"highlight_end":96},{"text":"            fn [<$($prefix)* norm1>](self) -> Self::$RealField;","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Multiplies this complex number by `factor`.","highlight_start":1,"highlight_end":60},{"text":"            fn [<$($prefix)* scale>](self, factor: Self::$RealField) -> Self;","highlight_start":1,"highlight_end":78},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Divides this complex number by `factor`.","highlight_start":1,"highlight_end":57},{"text":"            fn [<$($prefix)* unscale>](self, factor: Self::$RealField) -> Self;","highlight_start":1,"highlight_end":80},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// The polar form of this complex number: (modulus, arg)","highlight_start":1,"highlight_end":70},{"text":"            fn [<$($prefix)* to_polar>](self) -> (Self::$RealField, Self::$RealField) {","highlight_start":1,"highlight_end":88},{"text":"                (self.clone().[<$($prefix)* modulus>](), self.[<$($prefix)* argument>]())","highlight_start":1,"highlight_end":90},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// The exponential form of this complex number: (modulus, e^{i arg})","highlight_start":1,"highlight_end":82},{"text":"            fn [<$($prefix)* to_exp>](self) -> (Self::$RealField, Self) {","highlight_start":1,"highlight_end":74},{"text":"                let m = self.clone().[<$($prefix)* modulus>]();","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if !m.is_zero() {","highlight_start":1,"highlight_end":34},{"text":"                    (m.clone(), self.[<$($prefix)* unscale>](m))","highlight_start":1,"highlight_end":65},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    (Self::$RealField::zero(), Self::one())","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// The exponential part of this complex number: `self / self.modulus()`","highlight_start":1,"highlight_end":85},{"text":"            fn [<$($prefix)* signum>](self) -> Self {","highlight_start":1,"highlight_end":54},{"text":"                self.[<$($prefix)* to_exp>]().1","highlight_start":1,"highlight_end":48},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            fn [<$($prefix)* floor>](self) -> Self;","highlight_start":1,"highlight_end":52},{"text":"            fn [<$($prefix)* ceil>](self) -> Self;","highlight_start":1,"highlight_end":51},{"text":"            fn [<$($prefix)* round>](self) -> Self;","highlight_start":1,"highlight_end":52},{"text":"            fn [<$($prefix)* trunc>](self) -> Self;","highlight_start":1,"highlight_end":52},{"text":"            fn [<$($prefix)* fract>](self) -> Self;","highlight_start":1,"highlight_end":52},{"text":"            fn [<$($prefix)* mul_add>](self, a: Self, b: Self) -> Self;","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// The absolute value of this complex number: `self / self.signum()`.","highlight_start":1,"highlight_end":83},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// This is equivalent to `self.modulus()`.","highlight_start":1,"highlight_end":56},{"text":"            fn [<$($prefix)* abs>](self) -> Self::$RealField;","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Computes (self.conjugate() * self + other.conjugate() * other).sqrt()","highlight_start":1,"highlight_end":86},{"text":"            fn [<$($prefix)* hypot>](self, other: Self) -> Self::$RealField;","highlight_start":1,"highlight_end":77},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            fn [<$($prefix)* recip>](self) -> Self;","highlight_start":1,"highlight_end":52},{"text":"            fn [<$($prefix)* conjugate>](self) -> Self;","highlight_start":1,"highlight_end":56},{"text":"            fn [<$($prefix)* sin>](self) -> Self;","highlight_start":1,"highlight_end":50},{"text":"            fn [<$($prefix)* cos>](self) -> Self;","highlight_start":1,"highlight_end":50},{"text":"            fn [<$($prefix)* sin_cos>](self) -> (Self, Self);","highlight_start":1,"highlight_end":62},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn [<$($prefix)* sinh_cosh>](self) -> (Self, Self) {","highlight_start":1,"highlight_end":65},{"text":"                (self.clone().[<$($prefix)* sinh>](), self.[<$($prefix)* cosh>]())","highlight_start":1,"highlight_end":83},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            fn [<$($prefix)* tan>](self) -> Self;","highlight_start":1,"highlight_end":50},{"text":"            fn [<$($prefix)* asin>](self) -> Self;","highlight_start":1,"highlight_end":51},{"text":"            fn [<$($prefix)* acos>](self) -> Self;","highlight_start":1,"highlight_end":51},{"text":"            fn [<$($prefix)* atan>](self) -> Self;","highlight_start":1,"highlight_end":51},{"text":"            fn [<$($prefix)* sinh>](self) -> Self;","highlight_start":1,"highlight_end":51},{"text":"            fn [<$($prefix)* cosh>](self) -> Self;","highlight_start":1,"highlight_end":51},{"text":"            fn [<$($prefix)* tanh>](self) -> Self;","highlight_start":1,"highlight_end":51},{"text":"            fn [<$($prefix)* asinh>](self) -> Self;","highlight_start":1,"highlight_end":52},{"text":"            fn [<$($prefix)* acosh>](self) -> Self;","highlight_start":1,"highlight_end":52},{"text":"            fn [<$($prefix)* atanh>](self) -> Self;","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Cardinal sine","highlight_start":1,"highlight_end":30},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn [<$($prefix)* sinc>](self) -> Self {","highlight_start":1,"highlight_end":52},{"text":"                if self.is_zero() {","highlight_start":1,"highlight_end":36},{"text":"                    Self::one()","highlight_start":1,"highlight_end":32},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    self.clone().[<$($prefix)* sin>]() / self","highlight_start":1,"highlight_end":62},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn [<$($prefix)* sinhc>](self) -> Self {","highlight_start":1,"highlight_end":53},{"text":"                if self.is_zero() {","highlight_start":1,"highlight_end":36},{"text":"                    Self::one()","highlight_start":1,"highlight_end":32},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    self.clone().[<$($prefix)* sinh>]() / self","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Cardinal cos","highlight_start":1,"highlight_end":29},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn [<$($prefix)* cosc>](self) -> Self {","highlight_start":1,"highlight_end":52},{"text":"                if self.is_zero() {","highlight_start":1,"highlight_end":36},{"text":"                    Self::one()","highlight_start":1,"highlight_end":32},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    self.clone().[<$($prefix)* cos>]() / self","highlight_start":1,"highlight_end":62},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn [<$($prefix)* coshc>](self) -> Self {","highlight_start":1,"highlight_end":53},{"text":"                if self.is_zero() {","highlight_start":1,"highlight_end":36},{"text":"                    Self::one()","highlight_start":1,"highlight_end":32},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    self.clone().[<$($prefix)* cosh>]() / self","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            fn [<$($prefix)* log>](self, base: Self::$RealField) -> Self;","highlight_start":1,"highlight_end":74},{"text":"            fn [<$($prefix)* log2>](self) -> Self;","highlight_start":1,"highlight_end":51},{"text":"            fn [<$($prefix)* log10>](self) -> Self;","highlight_start":1,"highlight_end":52},{"text":"            fn [<$($prefix)* ln>](self) -> Self;","highlight_start":1,"highlight_end":49},{"text":"            fn [<$($prefix)* ln_1p>](self) -> Self;","highlight_start":1,"highlight_end":52},{"text":"            fn [<$($prefix)* sqrt>](self) -> Self;","highlight_start":1,"highlight_end":51},{"text":"            fn [<$($prefix)* exp>](self) -> Self;","highlight_start":1,"highlight_end":50},{"text":"            fn [<$($prefix)* exp2>](self) -> Self;","highlight_start":1,"highlight_end":51},{"text":"            fn [<$($prefix)* exp_m1>](self) -> Self;","highlight_start":1,"highlight_end":53},{"text":"            fn [<$($prefix)* powi>](self, n: i32) -> Self;","highlight_start":1,"highlight_end":59},{"text":"            fn [<$($prefix)* powf>](self, n: Self::$RealField) -> Self;","highlight_start":1,"highlight_end":72},{"text":"            fn [<$($prefix)* powc>](self, n: Self) -> Self;","highlight_start":1,"highlight_end":60},{"text":"            fn [<$($prefix)* cbrt>](self) -> Self;","highlight_start":1,"highlight_end":51},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":");","highlight_start":1,"highlight_end":3}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"CORE/src/matrix_444.rs","byte_start":4124,"byte_end":4132,"line_start":128,"line_end":128,"column_start":39,"column_end":47,"is_primary":true,"text":[{"text":"            assert_abs_diff_eq!(eigen.argument(), expected_phase, epsilon = 1e-10);","highlight_start":39,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ComplexField` which provides `argument` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":3080,"byte_end":3080,"line_start":98,"line_end":98,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use nalgebra::ComplexField;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `simd_argument` with a similar name","code":null,"level":"help","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":4124,"byte_end":4132,"line_start":128,"line_end":128,"column_start":39,"column_end":47,"is_primary":true,"text":[{"text":"            assert_abs_diff_eq!(eigen.argument(), expected_phase, epsilon = 1e-10);","highlight_start":39,"highlight_end":47}],"label":null,"suggested_replacement":"simd_argument","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `argument` found for struct `nalgebra::Complex<T>` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mCORE/src/matrix_444.rs:128:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m128\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             assert_abs_diff_eq!(eigen.argument(), expected_phase, epsilon = 1e-10);\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/simba-0.8.1/src/scalar/complex.rs:186:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m186\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     complex_trait_methods!(RealField);\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---------------------------------\u001b[0m \u001b[1m\u001b[94mthe method is available for `nalgebra::Complex<f64>` here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `ComplexField` which provides `argument` is implemented but not in scope; perhaps you want to import it\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m98\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse nalgebra::ComplexField;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `simd_argument` with a similar name\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m128\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            assert_abs_diff_eq!(eigen.\u001b[92msimd_\u001b[0margument(), expected_phase, epsilon = 1e-10);\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[92m+++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 5 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 5 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0599, E0600.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0599, E0600.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
