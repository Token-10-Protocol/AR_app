{"$message_type":"diagnostic","message":"cannot apply unary operator `-` to type `usize`","code":{"code":"E0600","explanation":"An unary operator was used on a type which doesn't implement it.\n\nErroneous code example:\n\n```compile_fail,E0600\nenum Question {\n    Yes,\n    No,\n}\n\n!Question::Yes; // error: cannot apply unary operator `!` to type `Question`\n```\n\nIn this case, `Question` would need to implement the `std::ops::Not` trait in\norder to be able to use `!` on it. Let's implement it:\n\n```\nuse std::ops::Not;\n\nenum Question {\n    Yes,\n    No,\n}\n\n// We implement the `Not` trait on the enum.\nimpl Not for Question {\n    type Output = bool;\n\n    fn not(self) -> bool {\n        match self {\n            Question::Yes => false, // If the `Answer` is `Yes`, then it\n                                    // returns false.\n            Question::No => true, // And here we do the opposite.\n        }\n    }\n}\n\nassert_eq!(!Question::Yes, false);\nassert_eq!(!Question::No, true);\n```\n"},"level":"error","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":1444,"byte_end":1457,"line_start":42,"line_end":42,"column_start":34,"column_end":47,"is_primary":true,"text":[{"text":"                        PHI.powi(-((i*j) % 13) as i32),","highlight_start":34,"highlight_end":47}],"label":"cannot apply unary operator `-`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"unsigned values cannot be negated","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0600]\u001b[0m\u001b[1m: cannot apply unary operator `-` to type `usize`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mCORE/src/matrix_444.rs:42:34\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         PHI.powi(-((i*j) % 13) as i32),\n   \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mcannot apply unary operator `-`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: unsigned values cannot be negated\n\n"}
{"$message_type":"diagnostic","message":"cannot divide `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<Complex<f64>, Dyn, Dyn>>` by `f64`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":1789,"byte_end":1790,"line_start":53,"line_end":53,"column_start":21,"column_end":22,"is_primary":true,"text":[{"text":"        data = data / norm;","highlight_start":21,"highlight_end":22}],"label":"no implementation for `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<Complex<f64>, Dyn, Dyn>> / f64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Div<f64>` is not implemented for `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<Complex<f64>, Dyn, Dyn>>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Div<Rhs>`:\n  `&Matrix<T, R, C, S>` implements `Div<T>`\n  `&Matrix<T, R1, C1, SA>` implements `Div<&Rotation<T, D2>>`\n  `&Matrix<T, R1, C1, SA>` implements `Div<Rotation<T, D2>>`\n  `Matrix<T, R, C, S>` implements `Div<T>`\n  `Matrix<T, R1, C1, SA>` implements `Div<&Rotation<T, D2>>`\n  `Matrix<T, R1, C1, SA>` implements `Div<Rotation<T, D2>>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: cannot divide `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<Complex<f64>, Dyn, Dyn>>` by `f64`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mCORE/src/matrix_444.rs:53:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         data = data / norm;\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mno implementation for `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<Complex<f64>, Dyn, Dyn>> / f64`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `Div<f64>` is not implemented for `Matrix<Complex<f64>, Dyn, Dyn, VecStorage<Complex<f64>, Dyn, Dyn>>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Div<Rhs>`:\n             `&Matrix<T, R, C, S>` implements `Div<T>`\n             `&Matrix<T, R1, C1, SA>` implements `Div<&Rotation<T, D2>>`\n             `&Matrix<T, R1, C1, SA>` implements `Div<Rotation<T, D2>>`\n             `Matrix<T, R, C, S>` implements `Div<T>`\n             `Matrix<T, R1, C1, SA>` implements `Div<&Rotation<T, D2>>`\n             `Matrix<T, R1, C1, SA>` implements `Div<Rotation<T, D2>>`\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `from_column_iterator` found for struct `Matrix<T, R, C, S>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":2097,"byte_end":2117,"line_start":63,"line_end":63,"column_start":30,"column_end":50,"is_primary":true,"text":[{"text":"        let input = DMatrix::from_column_iterator(","highlight_start":30,"highlight_end":50}],"label":"function or associated item not found in `Matrix<_, Dyn, Dyn, VecStorage<_, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Matrix<_, Dyn, Dyn, VecStorage<_, Dyn, Dyn>>` consider using one of the following associated functions:\nMatrix::<T, R, C, S>::from_data_statically_unchecked\nMatrix::<T, Dyn, Dyn, VecStorage<T, Dyn, Dyn>>::from_vec_storage\nMatrix::<T, R, C, S>::from_data","code":null,"level":"note","spans":[{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nalgebra-0.32.6/src/base/matrix.rs","byte_start":15905,"byte_end":15986,"line_start":317,"line_end":317,"column_start":5,"column_end":86,"is_primary":true,"text":[{"text":"    pub const unsafe fn from_data_statically_unchecked(data: S) -> Matrix<T, R, C, S> {","highlight_start":5,"highlight_end":86}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nalgebra-0.32.6/src/base/matrix.rs","byte_start":17104,"byte_end":17175,"line_start":346,"line_end":346,"column_start":5,"column_end":76,"is_primary":true,"text":[{"text":"    pub const fn from_vec_storage(storage: VecStorage<T, Dyn, Dyn>) -> Self {","highlight_start":5,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nalgebra-0.32.6/src/base/matrix.rs","byte_start":19479,"byte_end":19512,"line_start":403,"line_end":403,"column_start":5,"column_end":38,"is_primary":true,"text":[{"text":"    pub fn from_data(data: S) -> Self {","highlight_start":5,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is an associated function `from_iterator` with a similar name","code":null,"level":"help","spans":[{"file_name":"CORE/src/matrix_444.rs","byte_start":2097,"byte_end":2117,"line_start":63,"line_end":63,"column_start":30,"column_end":50,"is_primary":true,"text":[{"text":"        let input = DMatrix::from_column_iterator(","highlight_start":30,"highlight_end":50}],"label":null,"suggested_replacement":"from_iterator","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `from_column_iterator` found for struct `Matrix<T, R, C, S>` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mCORE/src/matrix_444.rs:63:30\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let input = DMatrix::from_column_iterator(\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `Matrix<_, Dyn, Dyn, VecStorage<_, Dyn, Dyn>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `Matrix<_, Dyn, Dyn, VecStorage<_, Dyn, Dyn>>` consider using one of the following associated functions:\n      Matrix::<T, R, C, S>::from_data_statically_unchecked\n      Matrix::<T, Dyn, Dyn, VecStorage<T, Dyn, Dyn>>::from_vec_storage\n      Matrix::<T, R, C, S>::from_data\n   \u001b[1m\u001b[94m--> \u001b[0m/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nalgebra-0.32.6/src/base/matrix.rs:317:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m317\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub const unsafe fn from_data_statically_unchecked(data: S) -> Matrix<T, R, C, S> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m346\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub const fn from_vec_storage(storage: VecStorage<T, Dyn, Dyn>) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m403\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_data(data: S) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an associated function `from_iterator` with a similar name\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[91m- \u001b[0m        let input = DMatrix::\u001b[91mfrom_column_iterator\u001b[0m(\n \u001b[1m\u001b[94m63\u001b[0m \u001b[92m+ \u001b[0m        let input = DMatrix::\u001b[92mfrom_iterator\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 3 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 3 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0599, E0600.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0599, E0600.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
